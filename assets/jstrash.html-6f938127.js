import{_ as n,o as s,c as a,e as o}from"./app-6fcf50f1.js";const t={},e=o(`<h2 id="js的垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#js的垃圾回收机制" aria-hidden="true">#</a> js的垃圾回收机制</h2><p>JavaScript 是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。释放的过程称为垃圾回收。</p><p>js的7种<strong>原始数据类型</strong>会放在<strong>栈内存</strong>中，而<strong>引用数据类型</strong>存放在<strong>堆内存</strong>中，同时引用地址信息存在栈内存。</p><p>我们操作对象实际是操作对象的引用，如定义一个函数时，会在堆内存中开辟一块内存空间，将函数体代码以字符串的形式存入，然后将这块内存的地址赋值给函数名，函数名和引用地址会存在栈上。</p><p>入栈和退栈是随着函数调用同步进行的，当函数结束后栈空间会被立即释放，里面的变量数据无法保留。如果要保留，比如闭包，必须将其存入堆内存中，闭包的变量就是存在堆内存中。</p><p>要想清除垃圾，首先要找到垃圾，有两种标记策略：</p><h3 id="引用计数-旧" tabindex="-1"><a class="header-anchor" href="#引用计数-旧" aria-hidden="true">#</a> 引用计数（旧）</h3><p>对象A如果有访问对象B的权限，叫做A引用B，如果没有对象引用这个对象，那这个对象将被回收</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">a</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">}</span>   <span class="token comment">//{a:1}被创建（后称为A），赋值给obj1，A的引用个数为1</span>
<span class="token keyword">let</span> obj2 <span class="token operator">=</span> obj1   <span class="token comment">//A的引用个数变为2</span>

obj1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//A的引用个数变为1</span>
obj2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//A的引用个数变为0，此时A将被回收</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>引用计数有一个严重的问题,就是循环引用,所谓的循环引用,就是对象 A 有一个指针指向对象B,而对象 B 也引用了对象A</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token constant">B</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token constant">A</span><span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token constant">B</span><span class="token punctuation">;</span>
  <span class="token constant">B</span><span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当foo函数执行结束，理应整个函数及内部变量都被回收，但根据引用计数法，A和B的引用次数都不为0，所以不会被回收.</p><p><strong>手动回收就是把null赋值给变量</strong></p><h3 id="标记清理" tabindex="-1"><a class="header-anchor" href="#标记清理" aria-hidden="true">#</a> 标记清理</h3><p>定义：通过算法标记使用的对象，然后清除没有标记的对象的内存空间。</p><p>**标记阶段：**对内存中所有的对象进行遍历，从根对象开始（全局对象）递归遍历对象的引用关系。每个被访问的对象，垃圾回收器会给它打上标记，表示该对象是可达的，不是垃圾。</p><p>**清除阶段：**垃圾回收器会遍历整个内存，对于没有标记的对象（被判断为垃圾）会立即回收，释放内存空间。</p><p>优点：</p><ul><li>可以准确找到不被引用的对象。也能够处理循环引用的问题</li></ul><p>缺点：</p><ul><li>标记清除进行垃圾回收操作时会暂停程序的执行，所以在进行垃圾清理时可能会感觉刀卡顿。</li><li>标记清除会在回收过程中产生大量不连续、碎片化的内存空间。可能导致后续的内存分配难以找到足够大的连续内存块，导致内存的使用率变低</li></ul><h3 id="标记整理" tabindex="-1"><a class="header-anchor" href="#标记整理" aria-hidden="true">#</a> 标记整理</h3><p>定义：标记清除的增强操作，标记阶段一致，但是清除阶段会先执行整理、移动对象位置，对内存空间进行压缩。</p><p>**标记阶段：**同标记清理，对所有活动对象进行标记</p><p>**整理阶段：**将内存中的活动对象移动到一端，使空闲空间连续，没有碎片化。</p><p>**清除阶段：**同标记清理，回收未标记对象的内存空间</p><p>优点：解决了内存空间碎片化的问题</p><p>缺点：垃圾回收时可能会造成卡顿、效率比标记清理低</p><h2 id="v8引擎垃圾回收策略" tabindex="-1"><a class="header-anchor" href="#v8引擎垃圾回收策略" aria-hidden="true">#</a> V8引擎垃圾回收策略</h2><p>分代式垃圾回收：</p><p>分代式垃圾回收的基本思想是<strong>根据对象的存活时间</strong>将内存划分为不同的<strong>代（Generation）</strong>，每一代都有不同的回收策略。</p><p>将内存按照对象的生命周期进行划分，可以更精确地对不同代的对象采取不同的回收策略，从而提高垃圾回收的效率和性能。</p><p><code>V8</code> 将堆分为两个空间,一个叫<code>新生代</code>,另一个叫<code>老生代</code>,老生代内存空间更大。</p><p><strong>新生代</strong>：存放的是存活时间较短的对象（经过一次垃圾回收后,就被释放回收掉），采用了基于<strong>Scavenge算法</strong>的快速垃圾回收策略，通过将内存分为两个半空间来进行垃圾回收，优化了对象的分配和回收过程。</p><p><strong>老生代</strong>：存放的是存活时间较长的对象（经过多次垃圾回收后仍存在），采用了基于<strong>标记-整理-清除算法</strong>的全垃圾回收策略，通过对整个堆进行标记和整理，以减少内存的碎片化，提高内存利用率。</p><h3 id="新生代垃圾回收" tabindex="-1"><a class="header-anchor" href="#新生代垃圾回收" aria-hidden="true">#</a> <strong>新生代垃圾回收</strong></h3><p>在V8引擎中，<strong>副垃圾回收器</strong>主要负责管理新生代的垃圾回收。</p><p><strong>Scavenge算法</strong>的具体实现中，主要采用了一种基于复制的<strong>Chenney算法：</strong></p><p><code>Cheney</code> 算法是一种采用复制的方式实现垃圾回收算法。它将堆内存一分为二,每一部分空间称为 <code>semispace</code>。在这两个 <code>semispace</code> 空间中,只有一个处于使用中,另一个处于空闲状态。</p><p>处于使用状态的 <code>semispace</code> 空间称为 <code>From</code> 空间,处于闲置状态的空间称为 <code>To</code> 空间。</p><p>新对象首先被分配到From空间中，当触发垃圾回收机制。回收过程分为以下几个阶段：（有点类似于标记-整理-清除）</p><ol><li><strong>标记阶段</strong>：从根对象（通常是全局对象）开始，通过引用关系进行遍历并标记所有活动对象。</li><li><strong>复制阶段</strong>：将所有活动对象从From空间复制到To空间，并且进行排序，使得To空间成为连续的内存块。</li><li><strong>清除阶段</strong>：对From空间进行清理，回收非活动对象所占用的内存空间。</li><li><strong>空间交换</strong>：在清除阶段完成后，From空间和To空间的角色会发生交换，即From空间变为To空间，To空间变为From空间。这样，下一次的垃圾回收就可以在新的To空间中进行。</li></ol><p>新生代对象晋升机制：</p><ul><li><strong>年龄达到阈值</strong>：每个对象都有一个年龄计数器，初始为0。每次经过一次垃圾回收，如果对象仍然存活，它的年龄计数器就会加1。当年龄计数器达到阈值时，对象就会被晋升到老生代内存。</li><li><strong>To空间的内存占用达到一定比例</strong>：当To空间的内存占用超过一定比例（通常是25%到50%）时，也会触发对象的晋升。这是为了避免新生代内存过快地被填满，导致频繁的垃圾回收。</li></ul><h3 id="老生代垃圾回收" tabindex="-1"><a class="header-anchor" href="#老生代垃圾回收" aria-hidden="true">#</a> <strong>老生代垃圾回收</strong></h3><p>在V8引擎中，<strong>主垃圾回收器</strong>主要负责管理老生代的垃圾回收。</p><p>由于<strong>Scavenge算法</strong>在处理长时间存活和大规模对象存储时存在效率和内存利用率方面的不足，V8 引擎选择使用<strong>标记-清除</strong>和<strong>标记-整理</strong>等算法来处理老生代的垃圾回收。</p><p><strong>全停顿：</strong></p><p>由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。这种行为叫做<strong>全停顿（Stop-The-World）</strong>。</p><p>在 <code>V8</code> 的分代式垃圾回收中,新生代中存活对象通常较少,所以即便它是<strong>全停顿</strong>的影响也不大。</p><p>但 <code>V8</code> 的老生代配置得较大,且存活对象较多,全堆垃圾回收的标记、清理、整理等动作造成的停顿就会比较明显。</p><p>为了降低全堆垃圾回收带来的停顿时间,<code>V8</code> 先从标记阶段入手,原本一次停顿完成的动作改为增量标记,也就是拆分为许多小 <code>步进</code>,每做完一 <code>步进</code> 就让 <code>JavaScript</code> 引用逻辑执行一小会儿,垃圾回收与应用逻辑交替执行直到标记阶段完成</p><h3 id="orinoco优化" tabindex="-1"><a class="header-anchor" href="#orinoco优化" aria-hidden="true">#</a> Orinoco优化</h3><p>orinoco为V8的垃圾回收器的项目代号，为了提升用户体验，解决全停顿问题，它提出了增量标记、三色标记法、惰性清理、并发、并行等优化方法。</p><h3 id="并发与并行" tabindex="-1"><a class="header-anchor" href="#并发与并行" aria-hidden="true">#</a> <strong>并发与并行</strong></h3><ul><li><p>并发是指两个或多个事件在同一时间间隔内发生(简单理解就是交替处理)。比如吃饭五秒，然后看五秒电视，再吃饭五秒，再看几秒电视</p></li><li><p>并行性是指系统具有同时进行运算或操作的特性(简单理解就是同时处理)。比如一边吃饭一边看电视</p></li></ul><h4 id="并行垃圾回收" tabindex="-1"><a class="header-anchor" href="#并行垃圾回收" aria-hidden="true">#</a> <strong>并行垃圾回收：</strong></h4><p>垃圾回收器在主线程中执行垃圾回收的任务的同时，再<strong>引入多个辅助线程来并行处理</strong>，这样就会加速垃圾回收的执行速度。</p><p>主线程和协助线程同时执行同样的工作,但是这仍然是一种全停顿的垃圾回收方式</p><h4 id="增量垃圾回收" tabindex="-1"><a class="header-anchor" href="#增量垃圾回收" aria-hidden="true">#</a> <strong>增量垃圾回收:</strong></h4><p>（有点像并发）</p><p>增量回收就是垃圾回收和程序应用多次交替执行，每次只做垃圾回收的一小部分，以此减少阻塞时间。</p><p>但是要怎样才能做到垃圾回收器随时暂停和重启，并且在重启的时候恢复到上一步执行的地方呢？</p><p>还有另一个问题，标记好的数据若是在暂停垃圾回收的过程中被修改了如何处理？</p><ul><li>针对上面的两个问题，V8的解决方案分别是<strong>三色标记法</strong>和<strong>写屏障</strong></li></ul><p><strong>三色标记法：</strong></p><p>在没有采用增量算法之前，老生代的垃圾回收是采用<strong>标记清理算法</strong>和<strong>标记整理算法</strong>，单纯使用黑色和白色来标记数据，在一次执行完整的标记前，垃圾回收会将所有数据设置为白色，然后从根开始深度遍历，将所有能访问到的数据标记为黑色，标记为黑色的数据对象就是活动对象，剩余的白色数据对象也就是待清理的垃圾对象。</p><p>如果采用增量回收，那当垃圾回收器再次启动时，内存有黑色和白色，就不知道下一步走哪里了。</p><p>为此，V8产生的三色标记法就是</p><p>白（未被垃圾回收器访问过，也意味着该对象可以被回收）</p><p>灰（已被垃圾回收器访问过，但其引用的其他对象还未被访问。也表明目前正在处理这个对象。）</p><p>黑（已被垃圾回收器访问过，并且其引用的其他对象也已被访问和标记。黑色对象是安全的，不会被回收。）</p><p>采用三色标记法后，恢复执行只要看内存有没有灰色节点，有就从灰色节点继续执行。如果没有，就开始清理工作</p><p><strong>写屏障：</strong></p><p>在一次暂停垃圾回收后，当发生了黑色的节点引用了白色的节点，写屏障机制会强制将被引用的白色节点变成灰色的，以此保证正确的数据标记</p><h4 id="并发垃圾回收" tabindex="-1"><a class="header-anchor" href="#并发垃圾回收" aria-hidden="true">#</a> <strong>并发垃圾回收：</strong></h4><p>(不太像并发)</p><ul><li>上面讲到的<strong>并行垃圾回收</strong>和<strong>增量垃圾回收</strong>依然会阻塞主线程，接下来讲的<strong>并发垃圾回收</strong>就可以解决这个问题。</li><li><strong>并发回收机制</strong>：指主线程在执行 JavaScript 的过程中，<strong>辅助线程</strong>能够在后台完成执行垃圾回收的操作。</li></ul><p>这种方式也要面对增量回收的问题，就是在垃圾回收过程中，由于JavaScript代码在执行，堆中的对象的引用关系随时可能会变化，主线程和辅助线程极有可能在同一时间去更改同一个对象，所以也要进行<strong>写屏障</strong>操作。</p><p>前面已经简单说明了并发和并行的区别，但是我的理解是这个并发垃圾回收只是用辅助线程来处理垃圾回收，不用主线程(或者主线程空闲的时候用用？)，和实际并发的概念并不符合。增量回收更符合并发的概念</p><p><strong>惰性清理</strong></p><p>在标记阶段完成后，就要进入清除阶段了。V8采用的是<strong>惰性清理(Lazy Sweeping)</strong>，采用这种延迟清理的原因是因为在增量标记之后，要进行清理非活动对象的时候，垃圾回收器发现了其实就算是不清理，剩余的空间也足以让JS代码跑起来，所以就延迟了清理，让JS代码先执行，或者<strong>只清理部分垃圾</strong>，而不清理全部。</p><h2 id="v8的优化总结" tabindex="-1"><a class="header-anchor" href="#v8的优化总结" aria-hidden="true">#</a> V8的优化总结</h2><h3 id="副垃圾回收器" tabindex="-1"><a class="header-anchor" href="#副垃圾回收器" aria-hidden="true">#</a> 副垃圾回收器</h3><ul><li><strong>副垃圾回收器（新生代）</strong> 所采用的就是<strong>并行回收</strong>策略，它在执行垃圾回收的过程中，启动了多个线程来负责新生代中的垃圾清理操作</li></ul><h3 id="主垃圾回收器" tabindex="-1"><a class="header-anchor" href="#主垃圾回收器" aria-hidden="true">#</a> 主垃圾回收器</h3><ul><li><p>2011 年，V8 将主垃圾回收器从 stop-the-world 标记切换到增量标记。但在 2018 年，GC(垃圾回收) 技术又有了一个重大突破，这项技术名为并发标记。</p></li><li><p>以上三种方式各有优缺点，而主垃圾回收器（老生代）</p><p>就融合了这三种机制，来实现垃圾回收。</p><ul><li>首先主垃圾回收器主要使用<strong>并发标记</strong>，在主线程执行 JavaScript时，辅助线程就开始执行标记操作了，所以标记是在辅助线程中完成的。</li><li>标记完成之后，再执行<strong>并行</strong>整理和清理操作。主线程在执行整理和清理操作时，多个辅助线程也在执行整理整理和清理操作。</li><li>另外，主垃圾回收器还采用了<strong>增量回收</strong>的方式，整理和清理的任务会穿插在各种 JavaScript 任务之间执行。</li></ul></li></ul>`,87),p=[e];function r(i,c){return s(),a("div",null,p)}const d=n(t,[["render",r],["__file","jstrash.html.vue"]]);export{d as default};
